#include "GameManager.h"
#include <iostream>

namespace GameManager
{
	constexpr double easy_mine_percent		{ 0.10 };
	constexpr double medium_mine_percent	{ 0.20 };
	constexpr double hard_mine_percent		{ 0.30 };
	constexpr int easy_dimensions	{ 10 };
	constexpr int medium_dimensions	{ 20 };
	constexpr int hard_dimensions	{ 30 };

	Difficulty size_difficulty{ Difficulty::easy };

	std::vector<TileState> minefield{ }; // 2D vector

	bool game_over { false };
	bool victory   { false };


	void PrintMinefield(std::vector<TileState> mines)
	{
		int dimensions{ GetDimensions() };

		for (int i = 0; i < minefield.size(); i++)
		{
			if (i != 0 && i % dimensions == 0) std::cout << std::endl;

			if (minefield[i] == TileState::mine) std::cout << "* ";
			else
			{
				std::cout << GetNeighbouringMines(i) << " ";
			}
		}

		std::cout << std::endl << std::endl;
	}

	// Generates a minefield by filling a vector with random integers, storing the ints in a map with their positions then sorting the vector
	// I then pick an index in the sorted vector for how many mines we want and allocate this as the threshold, anything under it is a mine in
	// the final vector minefield and everything else is unexplored until clicked
	void NewGame(Difficulty mine_amount, Difficulty size) 
	{
		int tile_count {};
		int mine_count {};
		unsigned int mine_threshold {};

		std::map<int, long unsigned int> mine_probability_map;		// Map and vectors are 2D represented as 1D
		std::vector<long unsigned int>	 sorted_mine_probability;	// long unsigned because that's what the rng spits out
		std::vector<int>  new_tile_state{};

		// Seed Mersenne Twister with current time and seven ints generated by random_device
		std::random_device rand_device;
		std::seed_seq seed{ static_cast<unsigned int>(std::chrono::steady_clock::now().time_since_epoch().count()), rand_device(), rand_device(), rand_device(), rand_device() };
		std::mt19937 random{ seed };

		// Setup tiles and mine count
		size_difficulty = size;
		tile_count = GetDimensions();
		tile_count *= tile_count;

		switch (mine_amount)
		{
			case GameManager::Difficulty::easy:
				mine_count = static_cast<int>(tile_count * easy_mine_percent);
				break;
			case GameManager::Difficulty::medium:
				mine_count = static_cast<int>(tile_count * medium_mine_percent);
				break;
			case GameManager::Difficulty::hard:
				mine_count = static_cast<int>(tile_count * hard_mine_percent);
				break;
			default:
				break;
		}

		// Randomly generate ints for mine probabilities
		for (int i = 0; i < tile_count; i++)
		{
			long unsigned int random_int{ random() };

			mine_probability_map[i] = random_int;
			sorted_mine_probability.push_back(random_int);
		}
		std::sort(sorted_mine_probability.begin(), sorted_mine_probability.end());

		mine_threshold = sorted_mine_probability[mine_count]; // Find the threshold of whether an int is a mine using amount of mines

		// populate actual minefield
		minefield.clear();

		for (int i = 0; i < tile_count; i++)
		{
			if (mine_probability_map[i] < mine_threshold) minefield.push_back(TileState::mine);
			else minefield.push_back(TileState::unexplored);
		
			new_tile_state.push_back(-1); // Unclicked
		}
		
#ifdef _DEBUG
		PrintMinefield(minefield);
#endif // _DEBUG

		game_over = false;
		victory   = false;
	}

	int GetDimensions()
	{
		int dimensions{};
		switch (size_difficulty)
		{
			case GameManager::Difficulty::easy:
				dimensions = easy_dimensions;
				break;
			case GameManager::Difficulty::medium:
				dimensions = medium_dimensions;
				break;
			case GameManager::Difficulty::hard:
				dimensions = hard_dimensions;
				break;
			default:
				break;
		}

		return dimensions;
	}

	bool IsGenerated() 
	{
		return minefield.size() != 0;
	}

	bool IsGameOver()
	{
		return game_over;
	}
	
	bool IsVictory()
	{
		return victory;
	}

	TileState GetTileState(int id) 
	{
		return minefield[id];
	}

	std::vector<int> GetNeighbouringTiles(int id)
	{
		int dimensions{ GetDimensions() };

		int neighbour_idx[]
		{
			//	Left			 Mid			  Right
			id - dimensions - 1, id - dimensions, id - dimensions + 1, // Top
			id - 1,								  id + 1,			   // Mid
			id + dimensions - 1, id + dimensions, id + dimensions + 1  // Bot
		};

		std::vector<int> neighbours{};

		for (int i = 0; i < 8; i++)
		{
			bool in_bounds		{ neighbour_idx[i] >= 0 && neighbour_idx[i] < minefield.size() };

			// Prevents the tiles on the left and right edge from wrapping around
			bool bleeding_edge_l{ id % dimensions == 0				&& (i == 0 || i == 3 || i == 5) };
			bool bleeding_edge_r{ id % dimensions == dimensions - 1 && (i == 2 || i == 4 || i == 7) };

			if (in_bounds && !bleeding_edge_l && !bleeding_edge_r)
			{
				neighbours.push_back(neighbour_idx[i]);
			}
		}

		return neighbours;
	}

	int GetNeighbouringMines(int id)
	{
		int tiles{ static_cast<int>(minefield.size()) };
		int count{ 0 };
				
		std::vector<int> neighbouring_tiles{ GetNeighbouringTiles(id) };

		for (int i = 0; i < neighbouring_tiles.size(); ++i)
		{
			if (minefield[neighbouring_tiles[i]] == TileState::mine || minefield[neighbouring_tiles[i]] == TileState::flagged_mine)
				++count;
		}

		return count;
	}

	int GetNeighbouringMines(std::vector<int> neighbours)
	{
		int tiles{ static_cast<int>(minefield.size()) };
		int count{ 0 };


		for (int i = 0; i < neighbours.size(); ++i)
		{
			if (minefield[neighbours[i]] == TileState::mine || minefield[neighbours[i]] == TileState::flagged_mine)
				++count;
		}

		return count;
	}

	void FlagTile(int id)
	{
		switch (minefield[id])
		{
			case TileState::unexplored:
				minefield[id] = TileState::flagged_tile;
				break;
			case TileState::mine:
				minefield[id] = TileState::flagged_mine;
				break;
			case TileState::flagged_tile:
				minefield[id] = TileState::unexplored;
				break;
			case TileState::flagged_mine:
				minefield[id] = TileState::mine;
				break;
			default:
				break;
		}
	}

	void ProcessTile(int id)
	{
		if (minefield[id] == TileState::mine) game_over = true;

		if (victory || game_over || minefield[id] != TileState::unexplored)
			return;

		switch (GetNeighbouringMines(id))
		{
			case 0:
				FloodFill(id);
				break;
			case 1:
				minefield[id] = TileState::one_adjacent_mine;
				break;
			case 2:
				minefield[id] = TileState::two_adjacent_mines;
				break;
			case 3:
				minefield[id] = TileState::three_adjacent_mines;
				break;
			case 4:
				minefield[id] = TileState::four_adjacent_mines;
				break;
			case 5:
				minefield[id] = TileState::five_adjacent_mines;
				break;
			case 6:
				minefield[id] = TileState::six_adjacent_mines;
				break;
			case 7:
				minefield[id] = TileState::seven_adjacent_mines;
				break;
			case 8:
				minefield[id] = TileState::eight_adjacent_mines;
				break;
			default:
				break;
		}

		// Check win condition
		bool not_won{};
		for (int i = 0; i < minefield.size(); i++)
		{
			if (minefield[i] == TileState::unexplored) not_won = true;
		}

		victory = !not_won;
	}

	void FloodFill(int id)
	{
		// Base cases
		if (minefield[id] == TileState::mine)		return;
		if (minefield[id] != TileState::unexplored) return;

		std::vector<int> neighbours{ GetNeighbouringTiles(id) };
		int mine_count{ GetNeighbouringMines(neighbours) };
	
		if (mine_count != 0)
		{
			ProcessTile(id);
			return;
		}

		// Process tile and neighbours
		minefield[id] = TileState::no_adjacent_mines;
		for (int idx : neighbours) FloodFill(idx);
	}
}